---
id: NodeEditorFunctions
title: Ganymede SDK Reference
displayed_sidebar: webUiSidebar
---

import NodeChip from '@site/src/components/NodeChip.js'


The Ganymede SDK provides a set of convenience functions for interacting with Ganymede.  To use the Python package on the platform, simply import the relevant module:

```python
import ganymede_sdk.editor
import ganymede_sdk.io
```

## ganymede_sdk.editor

ganymede_sdk.editor provides an interface for accessing data hosted on Ganymede

### class MockGanymedeContext

**GanymedeContext** stores _flow_ metadata such as user ID, input filenames, input parameters, and execution timestamp upon _flow_ execution.

**MockGanymedeContext** replicates the behavior of **GanymedeContext** in Editor notebooks, enabling users to replicate the environment of prior workflow executions in a Jupyter notebook environment.  When no parameters are passed into the object, calling **MockGanymedeContext()** with no parameters retrieves metadata from the most recent execution of the corresponding _flow_.

This enables users to test user-defined Python and SQL that incorporates metadata; for example, the **MockGanymedeContext** can be used to render [Jinja template variables](./FlowMetadata.mdx#template-variables) in a _retrieve_sql_ call, or to resolve references to the ganymede_context parameter within _execute_ functions.

```python
from ganymede_sdk.editor import MockGanymedeContext
from ganymede_sdk.io import retrieve_sql

# Create MockGanymedeContext with inputs from most recent run
mock_ganymede_context = MockGanymedeContext()

# Retrieve dataframe with run_id from most recent run
# Note: replace <tenant_name> with your tenant
query_sql = "SELECT * FROM <tenant_name>.tbl WHERE run_id = '{{ run_id }}'"
result = retrieve_sql(query_sql, context=mock_ganymede_context)
```

```python
import pandas as pd
from ganymede_sdk.editor import GanymedeContext, MockGanymedeContext
from ganymede_sdk.io import retrieve_sql

# Note: replace <tenant_name> with your tenant
query_sql = "SELECT * FROM <tenant_name>.input_table"

# User-editable Python function for node
def execute(df: pd.DataFrame, ganymede_context: GanymedeContext = None) -> pd.DataFrame:
  df['run_id'] = ganymede_context.run_id
  return df

# Use MockGanymedeContext object from most recent run in execute function
mock_ganymede_context = MockGanymedeContext()
df_input = retrieve_sql(query_sql)
df_output = execute(df_input, ganymede_context=mock_ganymede_context)
```

### class MockBenchlingContext

**MockBenchlingContext** retrieves Benchling connection information from the environment so users can make calls to their configured Benchling tenant in Jupyter notebooks.  If client ID and client secret are configured for the environment, declaring **MockBenchlingContext()** retrieves a Benchling connection.

Alternatively, _url_ and _api_key_ keyword parameters can be passed on initialization for authentication.  For more detail, see [Access the Benchling Developer Platform](https://help.benchling.com/hc/en-us/articles/9714802977805-Access-the-Benchling-Developer-Platform).

```python
from ganymede_sdk.editor import MockBenchlingContext

# Retrieve Benchling connection information from environment
mock_benchling_context = MockBenchlingContext()
print(mock_benchling_context.conn)
```

### class GPT

**GPT** allows users to make calls to the OpenAI GPT models as a coding assistant.  This requires configuring an OpenAI API Key for the environment, which can be done on the [Environment Administration](./AdminControls.mdx) page. Some example use cases of this class are shown below.

:::caution

Please ensure your internal corporate policies allow for usage following [OpenAI policies](https://openai.com/policies) such as the [OpenAI data usage policy](https://openai.com/policies/api-data-usage-policies) prior to enabling and using this feature.

:::

#### Basic question and answering
Calling GPT with no parameters initializes the API with a default persona.  The _render_ function renders the output from GPT in markdown.  By default, gpt-3.5-turbo is used.

```python
from ganymede_sdk.editor import GPT

gpt = GPT()
res = gpt.ask("How do I write a python function to print hello world")
res.render()
```

<img alt="Hello World with Chat GPT" src="https://ganymede-bio.mo.cloudinary.net/apiServer/HelloWorldEnglish_20230405.png"/>

#### Continuing a conversation
A conversation is continued when subsequent questions are asked.  Continuing along the lines of the example above, the following question continues the conversation with context from the earlier dialogue.

```python
res = gpt.ask("What about the same function in French")
res.render()
```

<img alt="Hello World with Chat GPT - French" src="https://ganymede-bio.mo.cloudinary.net/apiServer/HelloWorldFrench_20230405.png"/>

#### Clearing conversation history
Conversation history can be cleared by calling the _clear_history_ function.

```python
gpt.clear_history()
```

#### Coding assistance
Default coding prompts are available for assistance with common coding-related tasks.

```python
# List available actions
gpt.list_actions()

# For the execute function within a notebook, this call yields 
# step-by-step explanation of code behavior
gpt.ask(execute, action="explain_code")

# Generates a docstring in NumpyDoc format for the execute function
gpt.ask(execute, action="generate_docstring")
```

For the examples above, Python code can also be passed as a string to the _ask_ function to achieve the same results.

## ganymede_sdk.io

ganymede_sdk.io provides functions for accessing Ganymede cloud storage and data lake.

### function _retrieve_sql_

_retrieve_sql_ allows users to retrieve tabular data from the Ganymede data lake.  Input can either be a semicolon-delimited string containing a set of queries to run, or a dictionary of queries indexed by query name.

If the input is submitted as a semicolon-delimited string, the results are returned as a DataFrame if singular or a list of Pandas DataFrames if multiple queries are submitted.  If the input is submitted as a dictionary, results are returned as a dict of DataFrames keyed by query name.

- _param_ **query_str**: Union[str, Dict[str, str]] - Semicolon-delimited query string(s) to retrieve.
- _param_ **context**: Optional[GanymedeContext] - Context object used for rendering Jinja template variables in query
- _param_ **render_dict**: Optional[Dict[str, str]] - Dictionary used for rendering Jinja template variables in query.  Not used if context is provided.

#### Example Usage
```python
from ganymede_sdk.io import retrieve_sql

query_sql = {
  'query1': 'SELECT * FROM (SELECT "sample", "query")',
  'query2': 'SELECT * FROM (SELECT "sample", "query2")'
}

df_result_dict = retrieve_sql(query_sql)
```

### function _list_tables_

_list_tables_ provides a listing of all tables in the environment.

#### Example Usage
```python
from ganymede_sdk.io import list_tables

for table_name in list_tables():
  print(table_name)
```

### function _retrieve_files_

_retrieve_files_ allows users to retrieve files from Ganymede cloud storage.  

- _param_ **file_names**: Union[str, List[str]] - File or list of files to retrieve
- _param_ **input_or_output_bucket**: str - Either "input" or "output" - to reference bucket to retrieve files from
- _param_ **context**: Optional[GanymedeContext] - GanymedeContext to use for pulling file(s)

```python
from ganymede_sdk.io import retrieve_files

# Retrieves a file from the input bucket called "sample_test.csv"
input_file = retrieve_files("sample_test.csv", input_or_output_bucket="input")

# Retrieves 2 files from the output bucket
output_files = retrieve_files(['sample_output.xlsx', 'sample_validation.txt'], input_or_output_bucket="output")
```

### function _list_files_

_list_files_ lists files in the environment

- _param_ **input_or_output_bucket**: str - Either "input" or "output" - to reference whether to observe the input or output bucket of the _flow_.

```python
from ganymede_sdk.io import list_files

# Lists all files in the input bucket within the environment
for f in list_files(input_or_output_bucket="input"):
  print(f)
````